// DISCLAIMER: This code was partially generated by chatGPT
package frontend.ctrl;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;
import java.util.concurrent.atomic.DoubleAdder;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class MetricsController {

    public static final AtomicLong indexRequests = new AtomicLong(0);
    public static final AtomicLong predictRequests = new AtomicLong(0);

    private static final ConcurrentHashMap<String, AtomicLong> activeUsers =
            new ConcurrentHashMap<>();

    public static void userEntered(String page) {
        activeUsers.computeIfAbsent(page, k -> new AtomicLong(0)).incrementAndGet();
    }

    public static void userLeft(String page) {
        activeUsers.computeIfAbsent(page, k -> new AtomicLong(0)).decrementAndGet();
    }

    private static final AtomicLong latencyCount = new AtomicLong(0);
    private static double latencySum = 0;

    public static synchronized void recordPredictionLatency(double seconds) {
        latencyCount.incrementAndGet();
        latencySum += seconds;
    }

    private static final double[] UI_BUCKETS =
            {0.1, 0.3, 0.5, 1.0, 2.0, 5.0};

    private static final ConcurrentHashMap<String, AtomicLong> uiHistogram =
            new ConcurrentHashMap<>();

    // Per (endpoint|method|status) count & sum for histogram
    private static final ConcurrentHashMap<String, LongAdder> uiCount =
            new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, DoubleAdder> uiSum =
            new ConcurrentHashMap<>();

    public static void observeUiRequest(
            String endpoint, String method, String status, double seconds) {

        for (double bucket : UI_BUCKETS) {
            if (seconds <= bucket) {
                String key = endpoint + "|" + method + "|" + status + "|" + bucket;
                uiHistogram.computeIfAbsent(key, k -> new AtomicLong(0)).incrementAndGet();
            }
        }

        // +Inf bucket
        String infKey = endpoint + "|" + method + "|" + status + "|+Inf";
        uiHistogram.computeIfAbsent(infKey, k -> new AtomicLong(0)).incrementAndGet();

        // Count and sum for the histogram (per label set)
        String baseKey = endpoint + "|" + method + "|" + status;
        uiCount.computeIfAbsent(baseKey, k -> new LongAdder()).increment();
        uiSum.computeIfAbsent(baseKey, k -> new DoubleAdder()).add(seconds);
    }

    @GetMapping("/metrics")
    @ResponseBody
    public String metrics() {

        StringBuilder m = new StringBuilder();

        m.append("# TYPE index_requests_total counter\n");
        m.append("index_requests_total ")
         .append(indexRequests.get()).append("\n");

        m.append("# TYPE predict_requests_total counter\n");
        m.append("predict_requests_total ")
         .append(predictRequests.get()).append("\n");

        m.append("# TYPE active_users gauge\n");
        for (Map.Entry<String, AtomicLong> e : activeUsers.entrySet()) {
            m.append("active_users{page=\"")
             .append(e.getKey())
             .append("\"} ")
             .append(e.getValue().get())
             .append("\n");
        }

        m.append("# TYPE prediction_latency_seconds summary\n");
        m.append("prediction_latency_seconds_count ")
         .append(latencyCount.get()).append("\n");
        m.append("prediction_latency_seconds_sum ")
         .append(latencySum).append("\n");

        m.append("# TYPE ui_request_duration_seconds histogram\n");
        for (Map.Entry<String, AtomicLong> e : uiHistogram.entrySet()) {
            String[] parts = e.getKey().split("\\|");
            m.append("ui_request_duration_seconds_bucket")
             .append("{endpoint=\"").append(parts[0])
             .append("\",method=\"").append(parts[1])
             .append("\",status=\"").append(parts[2])
             .append("\",le=\"").append(parts[3])
             .append("\"} ")
             .append(e.getValue().get())
             .append("\n");
        }

        for (Map.Entry<String, LongAdder> e : uiCount.entrySet()) {
            String[] parts = e.getKey().split("\\|");

            m.append("ui_request_duration_seconds_count")
             .append("{endpoint=\"").append(parts[0])
             .append("\",method=\"").append(parts[1])
             .append("\",status=\"").append(parts[2])
             .append("\"} ")
             .append(e.getValue().sum())
             .append("\n");

            DoubleAdder sum = uiSum.get(e.getKey());
            m.append("ui_request_duration_seconds_sum")
             .append("{endpoint=\"").append(parts[0])
             .append("\",method=\"").append(parts[1])
             .append("\",status=\"").append(parts[2])
             .append("\"} ")
             .append(sum == null ? 0.0 : sum.sum())
             .append("\n");
        }

        m.append("# EOF\n");

        return m.toString();
    }
}
